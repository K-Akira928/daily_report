# 取り組んだ課題
- HTML & CSS 上級編
- HTML & CSS 道場レッスン上級編
- HTML & CSS Flexbox編
- Ruby I ~ Ruby V
- SQL I
# わかったこと
## 上級編
- レスポンシブデザイン
    - 様々なデバイスや画面サイズに合わせて、コンテンツのレイアウトを調整するための仕組み。スマートフォン表示に対応したサイト制作においては必須の技術。
    - レスポンシブデザインを適用する準備として、`<head>`タグ内にviewportを設定する。
- メディアクエリ
    - ブラウザの画面サイズに応じてCSSのスタイルを設定できる手法。
    - stylesheet.cssにメディアクエリ用のCSSを記述しても特に問題はないが、整理しやすいようにCSSを分割するべき。分割後のファイルを読み込む際には、必ずviewportよりも下の行に記述する必要がある。
    - `@media (条件) {...}` と記述する。指定された条件が当てはまるときにのみ`{ }`内のCSSが適用される。
    - メディアクエリの条件には、`max-width`(最大幅)、または`min-width`(最小幅)を設定できる。
    - `max-width: ○○ px`と指定すると、画面幅が○○px以下の時にCSSを適用できる。`min-width`はその反対。
    - また、上記`○○ px`の部分はブレイクポイントと呼ぶ。
    - メディアクエリ使用時に`padding`を加えた要素があると要素の合計幅が100%を超えてしまい、レイアウトが崩れることがある。そのような場合は`box-sizing:border-box`を用いることで防止できる。
        - `box-sizing`を`border-box`に指定すると、要素の幅(width)の合計に`padding`と`border`が含まれるようになる。(尚、marginは`border-box`での合計値に含まれない。)
        - `box-sizing:border-box;`を指定するときは、`*`(HTML全体)に対して指定することが推奨されている。
 ## Flexbox編

- floatなどで作成していた並び順を簡単に作れるようになる。
- `display:flex`は指定した要素の**子要素**を横並びにする。
- `flex:auto`は指定した要素の幅を親要素に合わせて伸縮することができる。
- `flex-wrap:wrap`を指定すると、子要素のサイズに応じて折り返すことができる。
    - 折り返したい要素の親要素に`flex-wrap:wrap`を指定する。折り返したい要素自身には列数に応じたwidthを指定する。
- `flex-direction:column`は子要素を上から下へ並べる。
    - 縦に並べたい要素の親要素に`flex-direction:column`を指定する。
# Command Line

## 基礎編

- touch ファイル名 で空のファイルを作成できる。
- cat ファイル名 でファイルの中身を表示できる。
- mkdir ディレクトリ名 でディレクトリを作成できる。

## ファイル構造

- cd ディレクトリ名 で指定したディレクトリに移動できる。
    - cd .. で１つ親のディレクトリに移動できる。
    - cd 単体で実行するとホームディレクトリに移動する。
- pwd でカレントディレクトリを表示できる。
- ls でカレントディレクトリ内の中身を確認できる。

## ファイルやディレクトリ操作

- mv 移動させたいファイル名 移動先のディレクトリ名 で指定したディレクトリにファイルを移動できる。
    - mv ディレクトリ名 移動先のディレクトリ名 でディレクトリごとの移動もできる。
    - mv ファイル名 新しいファイル名 でファイル名の変更ができる。
- cp コピーするファイル名 新しいファイル名 でファイルのコピーができる。
    - cp -r コピーするディレクトリ名 新しいディレクトリ名 でディレクトリのコピーができる。
- rm ファイル名 でファイルの削除ができる。
    - rm -r ディレクトリ名 でディレクトリの削除もできる。
# Ruby

## Ruby Ⅰ

- `puts “文字列”` で入力した文字列が出力される。
    - 数値を使うことで計算も可能。
    - `puts “文字列” + “文字列”` で文字列の結合も可能。
- `変数名 = 値` で変数を定義できる。
    - Rubyでの変数命名ルールの１つとして２語以上組み合わせた変数を付けるときは、(_)を使用する。
- 変数の値を文字列の中に含める方法。`#{変数名}`とすることで、変数を代入している値に置き換えて文字列に含めることができる。これを変数展開という。※ダブルクォーテーションを使った文字列の場合にしか変数展開が行われない。
- if文を書く際には、処理をifとendで囲む必要がある。
    - ifにelseを組み合わせると「そうでなければ○○を行う」という処理ができるようになる。
    - elsifを用いると「そうでなくもし△△であれば▲▲を行う」という処理ができるようになる。
    - 条件に、○○”かつ”というニュアンスを含ませる場合には**&&**を使う。この場合は条件のうちすべてがtrueならtureになる。
    - 条件に、○○”または”というニュアンスを含ませる場合には**||**を使う。この場合は条件のうち１つでもtrueならtrueになる。
- tureとfalseを真偽値と呼ぶ。成り立つ = true, 成り立たない = false
    - if文はこの真偽値を使って条件分岐している。

## Ruby Ⅱ

- 配列は**[値1, 値2, 値3]**のように作る。配列に入っているそれぞれの値の事を**要素**と呼ぶ。
    - 要素には前から順に0, 1, 2…と数字が割り振られている。これをインデックス番号という。
- 繰り返し処理をする場合には `配列.each do |変数名|` と書き、endまでの間に実行したい処理を書く。
- それぞれの変数の使用できる範囲のことをスコープと呼ぶ。
- ハッシュは **{キー１⇒ 値1, キー２ ⇒ 値2}** のように作る。
    - ハッシュの各要素の値は設定したキーを使って呼び出すことができる。**ハッシュ[キー]**
    - **ハッシュ[キー] = 値** と書くことで、キーと対応している値を更新することができる。
    - **ハッシュ[新しいキー] = 値** と書くことで、ハッシュに新しい要素を追加することができる。
- :name という書き方の事をシンボルという。シンボルとは、文字を[ ” ]や[ ’ ]で囲む代わりに、先頭に[ : ]をつけた書き方。文字列とは厳密には異なるが、基本的には同じように使用できる。
    - シンボルはハッシュのキーとしてよく使われる。尚、シンボルを用いた場合にはその値を用いる場合にもシンボルで指定する必要がある。
    - ハッシュのキーにシンボルを用いるときには省略した書き方をすることができる。**[:key ⇒]** を **[key:]** ※この場合にも取得の際にはシンボルを用いる必要がある。
- ifの条件には、真偽値以外でもnilも扱うことができる。**nil以外 = true, nil = false**
- 配列の要素にはハッシュも使うことができる。代入したハッシュはインデックス番号で取り出すこともできる。
    - 変数に代入したハッシュを使うことで、**変数[キー]** とすることでハッシュの要素の値を用いることができる。この書き方はさらに省略でき、**配列[インデックス番号][キー]** とすることで用いることもできる。

## Ruby Ⅲ

- メソッドとは複数の情報を１つにまとめたもので、`def メソッド名` と `end` の間にまとめたい処理を書くことでメソッドを作ることができる。
    - 引数とはメソッドを呼び出すときに一緒に引数を渡すことで、メソッドの中でその値を利用することができる。`def メソッド名(引数名)` で引数を指定できる。引数を渡してメソッドを呼び出す場合には`メソッド名(値)`と書く
    - 引数は複数受け取ることもでき、その場合は()の中に受け取る引数を( , )で区切って並べる。この時、左から順に第１引数、第２引数と呼ぶ。呼び出す際にも同じように( , )を用いる。
    - 呼び出し元で受け取る処理結果を戻り値と呼ぶ。メソッドの中でreturnを使うと、呼び出し元で値を受け取れるようになる。
        - if文で使うような条件式をreturnすると、その条件式の真偽値を返すことができる。※真偽値を返すメソッドは、メソッド名の末尾に( ? )を使う習慣がある。
    - キーワード引数を用いると呼び出し側で引数を明記することができる。キーワード引数を用いる場合には通常のメソッドの書き方に加えて、引数の後ろに( : )を付ける必要がある。

## Ruby Ⅳ

- 設計図の事をクラス、物のことをインスタンスと呼ぶ。クラスは class クラス名 とすることで定義できる。※クラス名は必ず大文字で始めること。
    - クラスのデータを定義する方法の１つに attr_accessor シンボル を使う方法がある。これを使うことでクラスのインスタンスに情報を持たせることができる。この情報のことをインスタンス変数という。
    - クラスをもとに新しくインスタンスを生成するには クラス名.new とする。また、変数にもインスタンスを代入できる。
    - インスタンス変数に値を代入するには インスタンス.変数名 = 値 と書くことで代入できる。
    - クラスの中でもメソッドを定義することができ、インスタンス.メソッド名 と書くことでメソッドを呼び出すことができる。これをインスタンスメソッドという。
    - self.変数名とすることで、インスタンス変数を扱うことができるようになる。インスタンスメソッドでは、変数selfに、呼び出したインスタンス自身が代入されている。
    - initializeメソッドは、インスタンスを生成した直後に自動で呼び出される。このメソッドに引数を設定することでインスタンス生成時にインスタンス変数も同時に作成することができる。
    - クラスから生成したインスタンスも、配列の要素にすることが可能。
- 入力を受け付けるには gets.chomp を使う。変数 = gets.chomp と書くことで、エンターキーを押されるまでに入力された値を変数に代入することができる。
    - gets.chomp.to_i とすることで入力された内容を数値に変換することが可能。

## Ruby Ⅴ

- クラスをもとにして新たなクラスを作ることを継承と呼ぶ。class 新しいクラス名 < もととなるクラス名 とすることで他のクラスを継承して新しいクラスを定義できる。この時のクラス関係を新しいクラスは子クラス、元となったクラスを親クラスと呼ぶ。
    - 継承すると子クラスには、親のインスタンス変数とインスタンスメソッドが引き継がれる。
    - 子クラスへのインスタンス変数の追加方法は変わらず attr_accessor を用いる。また、インスタンスメソッドも同様に追加できる。
    - 親クラスにあるメソッドと同じ名前のメソッドを子クラスで定義すると、メソッドを上書きすることができる。これをオーバーライドと呼ぶ。オーバーライドすると子クラスのインスタンスは親クラスのメソッドではなく子クラスで定義したメソッドを呼び出す。これはinitializeメソッドにも有効
    - オーバーライドしたメソッドの中でsuperとすると、親クラスの同盟のメソッドを呼び出せる。親クラスのメソッドの定義に合わせて、superに対して引数を渡す必要がある。
- クラスに対して呼び出すメソッドのことをクラスメソッドと呼ぶ。クラスメソッドは def クラス名.メソッド名 で定義できる。インスタンスメソッド名との違いはメソッド名の前にクラス名を書く必要があること。
    - クラスメソッドはクラスの中でも呼び出すことができる。
    - インスタンスメソッドとクラスメソッドの違いはインスタンスに対して呼び出すか、クラスに対して呼び出すかの違い。

# SQL

## SQL学習レッスン Ⅰ

- 表の事をテーブルと呼ぶ。また、縦列のことをカラム、横列の事をレコードと呼ぶ。
- データベースに送る命令をクエリと呼ぶ。
- データベースからデータを取得するにはSELECTを用いる。SELECTでどのカラムのデータを取得するかを選ぶ。`SLECT カラム名`
    - データベースには複数のテーブルが存在する場合があるため、FROMを用いて、SELECTで選んだカラムがどのテーブルのカラムかを指定する必要がある。最後に「ここまでがクエリです。」といういうことをデータベースに伝えるために( ; )を加えて完成。
    - 複数のカラムからデータを取得する際には、カラム名を( , )で区切る。全カラムのデータを取得する際には( * )
- 特定のデータを取得するためには、WHERE = どこの を使う。`WHERE カラム名 = レコードの条件`
    - WHERE の条件では比較演算子も使用できる。
    - ある文字を含むデータを取得するためには、LIKE演算子使う。`WHERE カラム名 LIKE 条件` また、LIKE演算子では(%)をワイルドカードとして扱う。
        - ワイルドカードの設置位置によって条件も変わる。文字列の後ろに設置した場合、○○で始まる文字列を検索することができる。このような検索を前方一致と呼ぶ。逆に文字列の前方に設置した場合、○○で終わる文字列を検索することができる。これを後方一致と呼ぶ。
    - ○○を含まないデータや○○に一致しないデータのような条件でデータを取得したい場合にはNOT演算子を使用する。`WHERE NOT カラム名`
    - NULLのデータを取得するにはIS NULLを使用する。`WHERE カラム名 IS NULL` 逆にNULLではないデータを取得する場合は IS NOT NULL を使用する。`WHERE カラム名 IS NOT NULL` ※NULLのデータやNULLでないデータを取得したい場合 ( = ) は使うことができない。
- AND演算子を使うと、WHEREに複数の条件を指定することができる。`WHERE 条件1 AND 条件2`
- OR 演算子は、条件１または条件２のどちらかを満たすデータを検索することができる。
- データを並び替えるにはORDER BYを使用する。`ORDER BY 並べ替えたいカラム名 並べ方`
    - ORDER BY の並べ方は昇順か降順かを指定する。昇順は小さい数から大きい数へ、降順は大きい数から小さい数へ向かう順序。SQLでは昇順は ASC、降順は DESC と指定する
- 最大で何件取得するかを指定するには LIMIT を使用する。`LIMIT データの件数` LIMITはクエリの末尾に記述することで、取得するデータの数を制限する。

# 次やること
- SQL II

# 感じたこと
- 上級編
  - box-sizing:border-boxを使うことでよりpaddingとmarginの違いが分かりやすく理解できた。
  - float と clearも同時に学んだが細かい原理までは理解できなかった。
- Flexbox編
  - floatを使わないでも要素を並び替えられることで他の要素との干渉がすくなさそうだと思った。
- Command Line編
  - 慣れるとGUIを使った作業よりも速く作業できそうだと思った。
- Ruby
  - クラス継承やオーバーライドなど、学ぶ前は何となく難しそうな機能だと思っていたが理解すると便利で管理しやすく、使いこなせるように頑張りたいと思った。
- SQL
  - 以前から学んでみたいと思っていたことの一つ。個人的にびっくりしたのは昇順と降順のイメージを逆で覚えていたこと。しっかり記憶を訂正していきたい。
- 全体を通して
  - 今日はメモも兼ねてスライドの内容等をまとめながら勉強をした。このやり方は時間がかかるが「あれなんだっけ？」とスライドに戻る回数が激減して身についている感が段違いだった。また、自分の理解しやすいようにまとめるため理解の速度も速いように思う。

# 学習時間
Today:7.0h Total:17.5h
