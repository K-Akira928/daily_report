## 取り組んだ課題
### SQL
- スッキリわかるSQL入門 第3版 ドリル256問付き! (スッキリわかる入門シリーズ) を読む
  - 11章まで
## わかったこと
- DBMSに複数の命令を送る際、1つ以上のSQL文を1かたまりとして送ることができる、これを **トランザクション** という
  - トランザクションは途中で処理が中断されないようにする、他の人が処理に割り込めないようにするルールがある
- DBMSが1かたまりのとしてSQL文を扱うことを **トランザクション制御** という
- トランザクションを使うと、どちらも実行されていない or どちらも実行されているという状態を保証できる
- トランザクションは `BEGIN` `COMMIT` `ROLLBACK` を使って記述する
- DBMSに対して複数の利用者が同時に処理を要求することで起きる副作用は大きく3つある
  - まだコミットされていない未確定の変更を他の人が読めてしまうことを **ダーティーリード** という
  - 2つのSELECT文の間でUPDATE文を他の人が実行し値が変更されると、2つ目のSELECT文と1つ目のSELECT文で検索結果が異なる副作用を **反復不能読み取り** という
  - 反復不能読み取りのINSERT文バージョンで2つ目のSELECT文での行数が変わってしまう副作用を **ファントムリード** という
- DBMSはトランザクションを実行する際、ほかのトランザクションからの影響を受けないようにそれぞれを分離して実行する
  - DBMSはこの制御を行うために、内部で **ロック** と呼ばれる仕組みを使用する
  - 自分のトランザクションがコミット or ロールバックで終了すると、かけた鍵(ロック)は解除され、他の人のトランザクションがその行を読み書きできるようになる
- 自分が読み書きしたい行を他人がロックしている間、その他人のトランザクションが完了するまで自分は待たされる
- 通常処理を待たされることで処理は遅くなるが、どの程度厳密にトランザクションを分離するかを指定することで安全性と速さを両立でき、この分離レベルを **トランザクション分離レベル** という
- 自動的にかけられるロックを明示的にロックする箇所を指定することも可能
  - ロックをかける際には制限の強さも指定することができ、**排他的ロック** と **共有ロック** をかけられる
- お互いにトランザクションのロックで待機状態になった場合、**デットロック** が発生する
  - 多くのDBMSにはデットロックを自動的に解決する仕組みが備わっており、片方のトランザクションを強制的に失敗させることでデットロックから抜け出せるようにする
  - デットロックの予防にはトランザクションの時間を短くする、同じ順番でロックするようにすることが挙げられる
- 権限を設定するためのSQL命令の総称を **DCL** という
  - 権限を付与する **GRANT文** と 権限をはく奪する **REVOKE文** がある
- テーブルを作成するには代表的なDDLである **CREATE TABLE文** を使う
  - この文には作成したいテーブル名、テーブルを構成する列と型の一覧を指定する
  - テーブルを作成する際にデフォルト値を決めておくことで内容がNULL状態のVALUESをINSERTしてもNULLではなくデフォルト値が代入される
    - デフォルト値を指定するには **DEFAULT** キーワードを指定する
- テーブルを削除するにはDDLの **DROP TABLE** を使用する
- テーブルの定義を更新するにはDDLの **ALTER TABLE** を使用する
  - 何をどう変更するかという内容を記述する
  - 既存のテーブルに新しく列を追加する場合、原則としてテーブルの1番後に追加される
- **制約** を使用すると、データ型よりも強い制限をかけることができる
  - 制約はCREATE TABLEの列定義の後ろに指定することが可能
  - 1つの列にカンマ区切りで複数の制約をつけることも可能
- 各制約の機能
- 外部キーで別のテーブルを参照しているのにその行が存在しない状態を **参照整合性の崩壊** という
- データベースで作成することのできる索引情報は **インデックス** と呼ばれる
  - インデックスは指定した列に対して作られる
  - インデックスが存在する列に対して検索されると、DBMSは自動でインデックスの使用を試みるので高速になる場合が多い
  - インデックスには名前を付けなければならない
  - インデックスを作成するにはDDLに属する **CREATE INDEX** を使用する
  - インデックス名はほかと重複しない範囲で任意の名前を付けられる
  - インデックスを削除する際には **DROP INDEX** で削除できる
  - 複数の列を1つのインデックスとする **複合インデックス** も作成可能
- **EXPLAIN PLAN** や **EXPLAIN** を使うと指定したSQL文を実行するプランを調べることができる
- 何度も同じ結果表を使う場合などに **ビュー(View)** を使うとビュー名を使ってテーブルのように使用できる
  - ビューの作成には **CREATE VIEW** を使う
  - ビューの削除には **DROP VIEW** を使う
- 独自の番号を振るために適切な番号を取得することを **採番** ともいう
  - すでに採番した番号や最後に採番した番号を専用テーブルに記録したりするテーブルを **採番テーブル** と呼ぶ
  - CREATE TABLEで列を定義する際に連番を振る列であると宣言するとデータが追加されるタイミングで自動的に連番が振られる列を定義できる
  - **シーケンス** と呼ばれる採番した最新の値を常に記憶し、現在の値や次の値を取り出すことのできる機能があるDBMSもある
    - シーケンスは **CREATE SEQUENCE** で作成し、**DROP SEQUENCE** で削除できる
- データを正確かつ安全に取り扱うための4つの特性として **ACID特性** が広く知られている
  - **Atomicity(原子性)** 処理が中断しても中途半端な状態にならない
  - **Consistency(一貫性)** データの内容が矛盾した状態にならない
  - **Isolation(分離性)** 複数の処理を同時実行しても副作用がない
  - **Durability(永続性)** 記録した情報は消滅せず保存され続ける
- 整合性を保ちつつバックアップを行う最も簡単な方法はデータベースを一旦停止してからバックアップを行う **オフラインバックアップ**
  - 多くのDBMSでは稼働しながら整合性のあるバックアップデータを取得できるオンラインバックアップ機能も備えている
- ログファイルを高頻度でバックアップすると、データ消失時にも最後のデータベースバックアップ以降に実行されたものを再実行することで、消失直前の時点までデータを復元できる
  - このログに記録されているSQL文を最時刻して障害が発生する直前の状態までデータを更新する処理のことを **ロールフォワード** という
## 次やること
- スッキリわかるSQL入門 第3版 ドリル256問付き! (スッキリわかる入門シリーズ) を読む
  - 12章から
## 感じたこと
- ビューは変数みたいなものなのかなと思ったけど乱用しすぎるのも良くなさそう
- 普段自分が使っているサービスでの不具合対応の裏側はこんな感じなんだろうというのが知れて解像度が上がった
## 学習時間
Today:3h Total:349h