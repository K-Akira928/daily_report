## 取り組んだ課題
### SQL
- スッキリわかるSQL入門 第3版 ドリル256問付き! (スッキリわかる入門シリーズ) を読む
  - 8章まで
## わかったこと
- 集計関数は他の関数とは処理が違い、全行を1まとめにしてから集計処理をする
  - 集計結果は必ず1行になる
- `COUNT(*)` は単純に行数をカウントする(NULLも含む)
  - `COUNT(列)` は指定列のNULL行を無視してカウントする
- SQLではデコボコ型(カラムAが5行に対しカラムBが1行)の結果表は認められていないのでエラーとなる
  - DBMSによっては値を補い動作するものもある
- グループ集計を行うSELECT文の選択列リストに指定する列は `GROUP BY` に基準列として指定されているか、集計関数による集計の対象になっていなければならない
  - これに当てはまらない列を抽出しようとすると、デコボコ型な結果表になってしまう
- 非常に大量のデータから集計結果を取り出す際に毎回実行し計算するのは時間がかかってしまうため、 **集計テーブル** を用いて工夫する
  - 1回の集計結果を別テーブルに格納し、そのテーブルを利用し次から集計を行う
  - 集計テーブルに格納されている内容は最新のデータを用いた集計よりも古くなる可能性があるので定期的に内容を更新する必要がある
- 大量のデータを集計する際には条件を絞り込んでから集計することで集計やグループ化を行う回数が減るのでパフォーマンスが向上する
- SQL文がネストしていることを **副問い合わせ** **福照会** **サブクエリ** という
  - 内部に複数のサブクエリを持つことやサブクエリの中に更にサブクエリを持つことも可能
  - サブクエリを含むSQL文ではサブクエリが先に実行され、その結果である具体的な値になる
- 単一行副問い合わせとはサブクエリの検索結果が1行1列の値になるパターン
  - 単一行副問い合わせは単一の値を記述するような場所であれば基本的にどこでも記述できる
- 複数行副問い合わせとはサブクエリの検索結果がn行1列の複数の値となるサブクエリ
  - 複数の値との判定を行うWHERE句の条件式、SELECT文のFROM句に記述できる
- 一部のDBMSでは結果がn行m列でも複数の列を組み合わせて同時に比較でき、このような複数の列の組み合わせの条件式を **行値式** という
  - このパターンのサブクエリは通常のSQL文で表を記述できる箇所、SELECT文のFROM句やINSERT文などで記述することができる
- サブクエリの内部からメインクエリの表や列を利用するサブクエリを **相関副問い合わせ** という
  - `EXISTS` 演算子とともに使われる
- ある2つのテーブルの間に情報としての関連がある関連を **リレーションシップ(Relationship)** という
- ほかのテーブルの関連行をさすための値を格納してリレーションシップを結ぶ役割を担う列を **外部キー** という
- 結合を繰り返して3つ以上のテーブルを結合することもできるが、この際には前から順に1つずつ処理が行われていく
- 自分自身のテーブルと結合させることも可能で、これを **自己結合(self join)** や **再帰結合(recursive join)** という
- 結合の条件には等価記号を用いることが多いが、等価記号以外の演算子を用いた条件式を記述することもかのうで、これを **非等価結合** という
  - 普通の結合に比べて処理が大きい点に注意
## 次やること
### SQL
- スッキリわかるSQL入門 第3版 ドリル256問付き! (スッキリわかる入門シリーズ) を読む
  - 9章から
## 感じたこと
- 章が進むにつれてどんどん楽しさがわかってきた
- 少しずつ問題を解くスピードが上がってきた
## 学習時間
Today:5h Total:346h