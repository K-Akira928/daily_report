## 取り組んだ課題
### Ruby
- プロを目指す人のためのRuby入門を読む
  - 4.9章まで
## わかったこと
- Rubyでは三項演算子を使うことができる
  - 例: `n > 10? '10より大きい':'10以下'`
- 通常メソッドを呼び出す際に過不足があるとエラーとなるがデフォルト値を設定すると引数の数を柔軟に変えることができる
  - `def メソッド名(引数1 = デフォルト値1, 引数2 = デフォルト値2)`
- 真偽値を返すメソッド名は慣習として `?` で終わらせる
- `!` で終わるメソッド名を破壊的メソッドといい、呼び出したオブジェクトの状態を変更してしまう
  - `!` がついていないメソッドにも破壊的なものはある
  - あくまで破壊的なメソッドと非破壊的なメソッドの両方がある場合に `!` が付けられている
- Ruby:3.0からはendを省略して1行でメソッドを定義できる、エンドレスメソッドが導入された
  - `def メソッド名 = 処理` `def メソッド名(引数1, 引数2) = 処理`
  - Ruby:3.0の時点では実験的機能なので業務で使う際には使用が確定してから
- ガベージコレクション(GC)
  - Rubyは使用されなくなったオブジェクトを回収して自動的にメモリを解放する。
- エイリアスメソッド
  - Rubyには同じメソッドに複数の名前がついていることがよくある
  - 例: length = size メソッド(どちらも文字数を返す)
- 擬似変数は値を読み出すことはできるが代入しようとするとエラーが発生する
- Rubyの変数にはオブジェクトそのものではなくオブジェクトへの参照が格納されている
  - なので同じオブジェクトを参照しているとオブジェクトの状態が変更されるとその変更が各変数に影響される
- puts, print, p, ppメソッドの処理の違いと使い分け
- メソッドに()を付けない場合は
  - 引数がない場合
  - グローバル関数のように使えるメソッドの場合
  - requireやraiseのような一見Rubyの予約語のように見えるメソッドの場合
- Minitestを使った自動テストの書き方
- テストクラスのクラス名は慣習として **Test** で終わる or **Test** で始まる名前を付けることが多い
- Minitestは `test_` で始まるメソッドを探してそれを実行する(複数定義しても可)
- Rubyの繰り返し処理の書き方
- 名前の重複により、他の変数やメソッドが参照できなくなることをシャドーイングという(できるだけ避ける方が望ましい)
- ブロックの記法で使う `do` と `end` は代わりに `{}` で囲んでもブロックを作れる
  - 改行を含む長いブロックを書く場合は `do & end` 1行でコンパクトに書きたいときは `{}` を使うとよい
- mapメソッドを使うとブロックの戻り値が配列の要素となる新しい配列を作成できる
- selectメソッドは各要素に対してブロックを評価してその戻り値が真の要素を集めた配列を返す
  - rejectメソッドはselectメソッドの反対で偽の要素を集めた配列を返す
- findメソッドはブロックの戻り値が真になった最初の要素を返す
- sumメソッドは要素の合計を求めるメソッド(文字列も可能)
- joinメソッドは配列の要素を連結して1つの文字列にする(区切り文字の指定も可能)
- `&:` を使うとブロックを簡略して書くことができるが、ブロックパラメータが1個だけ、ブロックの中で呼び出すメソッドには引数がない、ブロックの中ではブロックパラメータに大してメソッドを1回呼び出す以外の処理がない場合で使用できる
- Rubyで値の範囲を表すオブジェクトのことを範囲オブジェクトという
  - `最初の値..最後の値(最後の値を含む)` or `最初の値...最後の値(最後の値を含まない)`
  - 範囲オブジェクトに大してto_aメソッドを使うと値が連続する配列を作成できる
- リファクタリングとは外から見た振る舞いは保ったまま、理解や修正が簡単になるよう内部のコードを改善すること
- 配列に添え字を2つ使うと添え字の位置と取得する長さを指定できる
  - `配列[位置, 取得する長さ]`
- values_atメソッドを使うと取得したい要素の添え字を複数取得できる
- lastメソッドを呼ぶと配列の最後の要素を取得できる
  - 反対のfirstメソッドもある(先頭の取得)
- pushメソッドで複数の値を追加することもできる
  - 配列を展開して追加する場合には `*` を使い `配列1.push(*配列2)` とすることで展開して追加できる
- 指定した値に一致する要素を削除したい場合はdeleteメソッドを使う
- 2つの配列を連結する場合、concatメソッドに `+` 演算子を使う(元の配列を変更するかどうか)
  - `配列1.concat(配列2)` とした場合、配列1は変更されて配列2は変更されない
  - `+` を使うと元の配列を変更しないで新しい配列を作成する `配列1 + 配列2`
- 配列には和集合、差集合、積集合が使える(非破壊的)
  - 和集合には `|` を使う `配列1 | 配列2`
  - 差集合には `-` を使う `配列1 - 配列2`
  - 積集合には `&` を使う `配列1 & 配列2`
  - 本格的な集合演算を扱う際にはSetクラスを使うとよい
- 多重代入で残りの全要素を配列として受け取る際には左辺の変数に `*` を付ける
  - `変数1, *変数2 = 代入1, 代入2, 代入3` とするとこの場合、変数2に代入2と代入3の入った配列が作られる
- 総合的に配列を展開して複数の引数として扱いたい場合には配列の前に `*` を置く
- 個数に制限のない引数のことを可変長引数という
  - 自分の定義するメソッドで可変長引数を扱いたい場合は引数名の前に `*` を付ける
- %記法を使って配列を作成するとカンマではなく空白文字が要素の区切り文字となるため[]を使うよりも簡潔に書ける
  - `%w(要素1 要素2 要素3)`
- charsメソッドとsplitメソッドを使うと文字列を分解して配列に変換することができる
- Array.newの引数で同一のデフォルト値を設定するとデフォルト値は1つのオブジェクトを参照している
  - 回避するにはブロックを使ってデフォルト値を設定する
- イミュータブルなクラス(値)は破壊的変更はできない
- each_with_indexメソッドを使うと繰り返し要素の添え字が引数にはいる
  - `配列.each_with_index {|要素, 添え字|}`
  - with_indexメソッドを使うとmapメソッド等と組み合わせて添え字を取得できる
- ネストされた配列をブロックパラメータで指定する場合、要素分パラメータを用意すると値を別々に受け取ることが出来る
  - パラメータが不足する場合は要素が切り捨てられる
  - ブロックパラメータに `()` を使用すると配列の要素のまとまりを指定できる
- 番号指定パラメータを使うと明示的にブロックパラメータを指定できる
- `do ... end` よりも `{}` のほうが結合度が高い
## 次やること
- プロを目指す人のためのRuby入門を読む
  - 4.10章から
## 感じたこと
- リファクタリングで冗長だったコードがまとまっていく過程を知れて感動すると同時に壁の高さを知る
- ブロックが大事そうだと思ったが理解できているか不安
- 色々なメソッドを使いこなせるように頑張りたい
## 学習時間
Today:3.5h Total:226h