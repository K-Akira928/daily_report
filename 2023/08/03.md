## 取り組んだ課題
- プロを目指す人のためのRuby入門を読む
  - 8.5.8章まで
## わかったこと
- selfの場所によって表現が変わる
- クラスの継承が適切か判断する1つの方法として **is-aの関係** というものがある
  - is-a => サブクラスはスーパークラスの一種である 違和感がなければOK
  - サブクラスはスーパークラスの性質を特化させたもの
  - スーパークラスはサブクラスの性質を汎化させたもの
- superを使うとスーパークラスの同名のメソッドを呼び出せる
- サブクラスとスーパークラスで引数の数が同じの場合、superの引数を省略できる
- メソッドの引数に(*)のみが設定されていた場合、そのメソッドでは引数は使わないがスーパークラスで使うためという意味になる
  - Ruby3.0からは (*,**) このように書かなければならない
- privateメソッドはサブクラスでも呼び出せる
  - オーバーライドも可能でその際には可視性も変わる
- private等の影響を受けるのはインスタンスメソッドだけでクラスメソッドは影響を受けていない
  - `class << self` とすると、クラスメソッドもprivateになる
- アクセサメソッドをprivateにするにprivateキーワードにゲッターメソッドとセッターメソッドを記述する
- protectedはメソッドを定義したクラス自身、そのサブクラスのインスタンスメソッドからレシーバー付きで呼び出せる
- 定数をクラス買いから直接参照するには `クラス名::定数` と書く
- 定数をクラス外から参照させたくない場合は `private_constant` で定数名を指定する
- Rubyではメソッド内にスコープを限定した定数は定義できない
- 定数定義はそれ自体が値を返すため、配列を定数で定義しながらその要素も同時に定数として定義することも可能
- クラスをfreezeするとクラスは変更を受け付けなくなる
  - デメリットが大きいので普通はしない
  - 定数のみをfreezeする方が良い
- グローバル変数( `$` )を乱用すると理解しづらいプログラムを生み出す原因になるため特別な理由がない限り使用は避けるべき
- エイリアスメソッドを自分で定義するには `alias 新しい名前 元の名前` とする
  - 元のメソッド定義前にaliasを呼び出すとエラーが出るので注意
- メソッドの定義を後から削除するには `undef 削除するメソッドの名前` を使う
- 入れ子になったクラスを参照するには `外側のクラス::内側のクラス` として参照する
  - この手法はクラス名の予期せぬ衝突を防ぐ **名前空間(ネームスペース)** を作る場合によく使われる
    - 名前空間を作る場合にはクラスよりもモジュールが使われることが多い
- 一部の一見演算子に見える演算子はメソッドとして定義されているためクラスごとに再定義できる
- 既存の実装を上書きして自分が期待する挙動に変更することをモンキーパッチと呼ぶ
  - デメリットもあるため乱用は厳禁
  - 最初に検討すべきはオープンクラスやモンキーパッチに頼らずに要件を満たせるかどうか
- `オブジェクト.メソッド名` という形で定義すると特定のオブジェクトにだけ紐づくメソッドができる、これを **特異メソッド** と呼ぶ
    - クラスメソッドも特異メソッド( `self.メソッド名` )
- モジュールの用途
  - 継承を使わずにクラスにインスタンスメソッドを追加、上書きする
  - 複数のクラスに対して共通の特異メソッドを追加
  - クラス名や定数名の衝突を防ぐために名前空間を作る
  - 関数的メソッドを定義する
  - シングルトンオブジェクトのように扱って設定値などを保持する
- モジュールの定義方法は `module モジュール名 end`
  - モジュールはインスタンスを作成することはできない、他のモジュールを継承することはできない
  - クラスの継承は適当ではないが、共通の機能は持たせたい時に選択肢として挙がるのがモジュール
- クラス内でincludeするとモジュールのメソッドが使えるようになる
  - モジュールをクラスにincludeして機能を追加することを **ミックスイン** という
  - publicメソッドにする必要がなければモジュール側でprivateメソッドとしておくと、includeしたクラスでもprivateメソッドして扱われる
- モジュールを使ったメソッド定義のもうひとつの方法として `extend` がある
  - `extend` を使うと、モジュール内のメソッドをそのクラスの特異メソッドにできる
- `include?` をクラスオブジェクトに対して呼ぶと引数で渡したモジュールがincludeされているかわかる
- `included_modules` メソッドを呼ぶとincludeされているモジュールの配列が返る
- `ancestors` メソッドを使うとモジュールだけではなくスーパークラスの情報も配列になって返ってくる
- クラスや構文に囲まれていない一番外側の部分を **トップレベル** という
  - トップレベルにはmainという名前のObjectクラスのインスタンスがselfとして存在している
- モジュール内で定義したメソッドの中でインスタンス変数を読み書きすると、include先のインスタンス変数を読み書きしたことと同義になる
  - ミックスイン先のクラスでインスタンス変数を直接参照するのは良い設計ではない
  - セッターメソッドを経由するとミックスイン先のクラスでセッターメソッドが未定義の場合エラーが発生して問題に気付ける
- トップレベルに記載したメソッドは事実上のグローバルメソッドとなる(Objectクラスがほぼ全てのクラスのスーパークラスなため)
## 次やること
- プロを目指す人のためのRuby入門を読む
  - 8.6章から
## 感じたこと
- こういう基礎部分が大事なのはわかっているので時間がかかってでも出来る範囲で理解できるようになりたい
- スーパークラスとサブクラスの関係への理解が今日1日で大分深まった気がする
  - 普段何気なく使っているメソッドがどこのクラスに所属しているかなど良い知見を得た
## 学習時間
Today:4h Total:236.5h