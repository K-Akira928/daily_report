## 取り組んだ課題
- プロを目指す人のためのRuby入門を読む
  - 9章まで
## わかったこと
- モジュールの中にクラスを定義すると、○○モジュールの××クラス となるので仮に同名のクラスだったとしても区別して扱える(名前空間)
  - モジュールに属するクラスを参照する際には `モジュール::クラス名` と `::` でモジュール名とクラス名を区切る
  - 名前空間は名前の衝突を防ぐだけでなく、クラスのグループ分けやカテゴリ分けをする目的で使われる場合もある
  - 名前空間として使うモジュールが既にどこかで定義されている場合、`モジュール::クラス名` の形でクラスを定義することも可能
- モジュール自身に特異メソッドを定義すると `モジュール名.メソッド名` という形で呼び出すことが出来る
  - クラスと違ってnewする必要がないため、メソッドの集まりとして扱いたい場合に向いている
- ミックスインとしても使えて特異メソッドとしても使えるメソッドを定義する場合は `module_function` メソッドを使う
  - `module_function` メソッドは対象のメソッド定義よりも下で呼び出す
  - ミックスインとしても、モジュールの特異メソッドとしても使えるメソッドのことを **モジュール関数** と呼ぶ
- `prepend` を使ってモジュールをミックスインすると同名のメソッドがあった時にミックスインしたクラス先よりもモジュールのメソッドが呼ばれる
  - 元の実装を活かしながら振る舞いを変更できる
- `refinements` を使うにはモジュールを作成し、`refine` メソッドを使って `refinements` を適用するクラスを指定し、ブロックの中に追加する機能を書いていく
  - 有効にするには `using` メソッドを使う
  - `refinements` で使うモジュールの内部には複数のrefineを定義できる
- Rubyで例外処理を書くには、 `begin..例外が起きうる処理..rescue..例外が発生した場合の処理..end` と書く
  - `message` メソッドは例外発生時のエラーメッセージを返す
  - `backtrace` メソッドはメソッドの呼び出し履歴を返す
  - 例外オブジェクトから情報を取得する際には `begin...rescue => 例外オブジェクトを格納する変数...end` とし、定義した変数に対してメソッドで情報を呼び出す
  - 例外オブジェクトが一致した場合のみに例外を補足する場合は `begin...rescue 補足したい例外クラス...end` とする
- 全ての例外クラスはExceptionクラスを継承している
  - StandardErrorクラスは通常のプログラムで発生する可能性の高い例外を表すクラス
  - NoMemoryErrorやSystemExitクラスは通常のプログラムでは発生しない特殊なエラー
  - rescue節にExceptionクラスやStandardErrorと無関係の例外クラスを指定することは避けるべき
- クラスの継承関係を意識しておかないと不適切な例外処理を作ってしまう恐れがあるので注意
- 何度かやり直すことで正常に実行できる場合がある時は、rescue節で `retry` を実行するとbegin節の最初からやり直せる
  - 無条件に `retry` し続けると無限ループになってしまうのでカウンタ変数などで制限すると良い
- 意図的に例外を発生させる場合には `raise` メソッドを使う
  - `raise` メソッドに文字列を渡すとその文字列がエラーメッセージとなる
- 例外が発生してもrescueしないというのが原則の考え方
  - 例外処理を書く場合は例外が発生しそうな箇所と例外クラスをあらかじめ予想する
  - 条件分岐を使った方が可読性やパフォーマンスの面で有利、例外処理を書く前に問題の有無を事前に確認できるメソッドがないかチェックする
- 例外の有無に関わらず実行する処理は `ensure` の後に書く
  - Rubyでは使用したら必ずリソースを開放するという処理をブロック付きのメソッドを使うことで自動的に処理できるケースが多いため、ensure節を書く前に確認する
- 例外が発生しなかった場合に実行される `else` 節を書くこともできる
  - `else` 節は `rescue` 節と `ensure` 節の間に置く
- 例外処理にも戻り値があり、最後まで正常に処理が進んだ場合 `begin` 節の最後の式が戻り値になる
- `ensure` 節では `return` を使わないようにする
- `rescue` 修飾子を使うとStandardErrorとそのサブクラスが補足される
- 最後に発生した例外は組み込み変数の `&!` に、バックトレース情報は `$@` に格納される
  - コードの可読性を考えると、通常は組み込み変数を使わないコードの方が望ましい
- メソッドの中身全体が例外処理で囲まれている場合は `begin...end` を省略して書ける
  - `do...end` でも同様
  - 同じブロックでも `{}` を使った場合は省略不可
- `rescue` 内で `raise` メソッドを使用できる、使用すると引数なしの場合 `rescue` 節で補足した例外をもう1度発生させることができる
  - プログラム事態は異常終了させるが、その情報はログに残したりする際に使える
- 例外クラスは独自に定義することも可能だが、特別な理由がない限りStandardErrorクラスかそのサブクラスを継承する
## 次やること
- プロを目指す人のためのRuby入門を読む
  - 10章から
## 感じたこと
- 少しずつ全体をオブジェクトとして捉えるイメージが湧いてきた気がする...？
- 何よりも公式のリファレンスを読まないといけないということがわかった
## 学習時間
Today:2.5h Total:239h